#define THREADS 64
#define PI 3.14159265358979323846

int ParticleCount;
int BoundaryCount;
float GridSize;
float3 GridMin;
float3 GridLength;
float KernelRadiusRate;

StructuredBuffer<float3> Positions;
StructuredBuffer<float3> BoundaryPositions;

RWStructuredBuffer<uint2> IndexMap;

int3 Quantize(float3 position)
{
    position = position - GridMin;
    int3 result = {
        floor(position.x / GridSize),
        floor(position.y / GridSize),
        floor(position.z / GridSize)
    };
    return result;
}

uint Hash(int3 p)
{
    return p.x + p.y * GridLength.x + p.z * GridLength.x * GridLength.y;
}

#pragma kernel HashPosition

[numthreads(THREADS, 1, 1)]
void HashPosition(int id: SV_DISPATCHTHREADID)
{
    int2 index;
    index.y = id;
    if (id < ParticleCount)
    {
        index.x = Hash(Quantize(Positions[id]));
        IndexMap[id] = index;
    } 
    else if (id < ParticleCount + BoundaryCount)
    {
        index.x = Hash(Quantize(BoundaryPositions[id - ParticleCount]));
        IndexMap[id] = index;
    }
}

#define BITONIC_FLIP 0
#define BITONIC_DISPERSE 1

void CompareAndSwap(int left, int right)
{
    if (right >= ParticleCount + BoundaryCount) {
        return;
    }
    if (IndexMap[left].x > IndexMap[right].x)
    {
        uint2 temp = IndexMap[left];
        IndexMap[left] = IndexMap[right];
        IndexMap[right] = temp;
    }
}

uint IndexMapCount;
uint BitonicStage;
uint BitonicBlockSize;

#pragma kernel BitonicSort

[numthreads(THREADS, 1, 1)]
void BitonicSort(int id: SV_DISPATCHTHREADID)
{
    uint q = ((2 * id) / BitonicBlockSize) * BitonicBlockSize;
    uint halfH = BitonicBlockSize / 2;
    uint offset = id % halfH;
    if (BitonicStage == BITONIC_FLIP)
    {
        CompareAndSwap(q + offset, q + BitonicBlockSize - 1 - offset);
    }
    else if (BitonicStage == BITONIC_DISPERSE)
    {
        CompareAndSwap(q + offset, q + halfH + offset);
    }
}

RWStructuredBuffer<int2> Table;

#pragma kernel MapTable

[numthreads(THREADS, 1, 1)]
void MapTable(int id: SV_DISPATCHTHREADID)
{
    if (id < ParticleCount + BoundaryCount)
    {
        uint hash = IndexMap[id].x;
        if (id == 0 || hash != IndexMap[id - 1].x)
        {
            Table[hash].x = id;
        }
        if (id == ParticleCount + BoundaryCount -1 || hash != IndexMap[id + 1].x)
        {
            Table[hash].y = id + 1;
        }
    }
}

struct Particle
{
    float radius;
    float restDensity;
    float viscosity;
    float gasConstant;
};

StructuredBuffer<float> Masses;
StructuredBuffer<Particle> Particles;

RWStructuredBuffer<float> Densities;
RWStructuredBuffer<float> Pressures;

#pragma kernel ComputeDensityAndPressure

[numthreads(THREADS, 1, 1)]
void ComputeDensityAndPressure(int id : SV_DISPATCHTHREADID)
{
    if (id > ParticleCount)
    {
        return;
    }
    float3 positioni = Positions[id];
    Particle particle = Particles[id];
    float mass = 1.0f / Masses[id];
    float kernelRadius = particle.radius * KernelRadiusRate;
    float kernelRadius2 = kernelRadius * kernelRadius;
    float poly6Constant = mass * 315.0f / (64.0f * PI * pow(abs(kernelRadius), 9.0f));

    float density = 0;

    int3 gridPosition = Quantize(positioni);
    for (int x = -1; x <=1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            for (int z = -1; z <= 1; z++)
            {
                int neighborHashIndex = Hash(gridPosition + int3(x, y, z));
                for (int mapIndex = Table[neighborHashIndex].x; mapIndex < Table[neighborHashIndex].y; mapIndex++)
                {
                    int n = IndexMap[mapIndex].y;
                    float3 positionj;
                    if (n < ParticleCount)
                    {
                        positionj = Positions[n];
                    }
                    else
                    {
                        positionj = BoundaryPositions[n - ParticleCount];
                    }

                    float distance2 = dot(positioni - positionj, positioni - positionj);
                    if (distance2 < kernelRadius2)
                    {
                        density += poly6Constant * pow(abs(kernelRadius2 - distance2), 3.0f);
                    }
                }
            }
        }
    }

    Densities[id] = density;
    Pressures[id] = max(particle.gasConstant * (density - particle.restDensity), 0);
}
